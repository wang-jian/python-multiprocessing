{
  "name": "Python-multiprocessing",
  "tagline": "主要讨论了thread的库，multiprocessing和multiprocessing.dummy，并写了个小测试程序",
  "body": "# python 多线程 \r\n\r\n\r\n\r\n## 相关库\r\n\r\n\r\n### A.threading\r\n    一般最常用的python实现是cpython，cpython实现中，由于GIL(Global Interpreter Lock)的存在，threading库其实只是单线程在跑，而且由于多线程增加的上下文切换开销，反而比单线程还慢（主要在CPU密集的场景）。\r\n    \r\n    GIL简单理解（没细研究），一个python解释器的全局所，所以起多线程的时候，每个线程都会等这个锁，和单线程跑是一样的。\r\n\r\n    JPython等由于比较小众，发展较慢，有些库不太全所以大家也只能还是用CPython\r\n\r\n### B.multiprocessing and Map\r\n\r\n    注意名字，人家叫多进程不是多线    程。实现的时候也是多进程，这个每个python解释器单独运行，各用个的锁，就解决了上面多线程反而效率更低的问题了。  \r\n    \r\n    但毕竟变成了进程，线程的优势就没了，比如共享内存什么的。\r\n\r\n    再但是，还有multiprocessing.dummy。官方文档只说了一句：\r\n   \r\n> multiprocessing.dummy replicates the API of multiprocessing but is no more than a wrapper around the threading module.\r\n \r\n没说一样对吧。其实它是在多进程的基础上，又起了多线程，因此还是会受到GIL的影响。看到有些帖子对比使用map和multiprocessing.dummy的效率，自己也写了段代码试了一下\r\n\r\n```\r\n    \r\n    from multiprocessing.dummy import Pool as ThreadPool\r\n    import time\r\n    \r\n    d = 0\r\n\r\n    def add(up):\r\n        global d\r\n        d += up\r\n    \r\n    start = time.time()\r\n    results = map(add, xrange(400000000))\r\n    print ('Normal:', time.time() - start)\r\n    \r\n    d = 0\r\n    start2 = time.time()\r\n    \r\n    pool = ThreadPool(processes=8)\r\n    results2 = map(add, xrange(400000000))\r\n    pool.close()\r\n    pool.join()\r\n    print ('Thread Pool:', time.time() - start2)```\r\n\r\n\r\n\r\n多次 试验基本都这个结果::\r\n\r\n    root@LFG1000186280:/tmp# python py-mulit-thread.py\r\n    ('Normal:', 48.061574935913086)\r\n    ('Thread Pool:', 52.3256778717041)\r\n\r\n\r\n网上的帖子对比的是打开链接的速度，不属于CPU密集型操作， 其实无法说明GIL的影响，GIL本来就是在CPU密集型场景下有问题。          multiprocessing.dummy在多进程中开多线程，加上GIL的影响，线程切换开销，应该比多进程差才对。\r\n\r\n## Reference\r\n1. [segmentfualt](https://segmentfault.com/a/1190000000414339)\r\n\r\n2. [multiprocessing.dummy 效率问题](http://stackoverflow.com/questions/26432411/multiprocessing-dummy-in-python)",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}