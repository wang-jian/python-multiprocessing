<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Python-multiprocessing by wang-jian</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Python-multiprocessing</h1>
      <h2 class="project-tagline">主要讨论了thread的库，multiprocessing和multiprocessing.dummy，并写了个小测试程序</h2>
      <a href="https://github.com/wang-jian/python-multiprocessing" class="btn">View on GitHub</a>
      <a href="https://github.com/wang-jian/python-multiprocessing/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/wang-jian/python-multiprocessing/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="python-多线程" class="anchor" href="#python-%E5%A4%9A%E7%BA%BF%E7%A8%8B" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>python 多线程</h1>

<h2>
<a id="相关库" class="anchor" href="#%E7%9B%B8%E5%85%B3%E5%BA%93" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>相关库</h2>

<h3>
<a id="athreading" class="anchor" href="#athreading" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>A.threading</h3>

<pre><code>一般最常用的python实现是cpython，cpython实现中，由于GIL(Global Interpreter Lock)的存在，threading库其实只是单线程在跑，而且由于多线程增加的上下文切换开销，反而比单线程还慢（主要在CPU密集的场景）。

GIL简单理解（没细研究），一个python解释器的全局所，所以起多线程的时候，每个线程都会等这个锁，和单线程跑是一样的。

JPython等由于比较小众，发展较慢，有些库不太全所以大家也只能还是用CPython
</code></pre>

<h3>
<a id="bmultiprocessing-and-map" class="anchor" href="#bmultiprocessing-and-map" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>B.multiprocessing and Map</h3>

<pre><code>注意名字，人家叫多进程不是多线    程。实现的时候也是多进程，这个每个python解释器单独运行，各用个的锁，就解决了上面多线程反而效率更低的问题了。  

但毕竟变成了进程，线程的优势就没了，比如共享内存什么的。

再但是，还有multiprocessing.dummy。官方文档只说了一句：
</code></pre>

<blockquote>
<p>multiprocessing.dummy replicates the API of multiprocessing but is no more than a wrapper around the threading module.</p>
</blockquote>

<p>没说一样对吧。其实它是在多进程的基础上，又起了多线程，因此还是会受到GIL的影响。看到有些帖子对比使用map和multiprocessing.dummy的效率，自己也写了段代码试了一下</p>

<pre><code>
    from multiprocessing.dummy import Pool as ThreadPool
    import time

    d = 0

    def add(up):
        global d
        d += up

    start = time.time()
    results = map(add, xrange(400000000))
    print ('Normal:', time.time() - start)

    d = 0
    start2 = time.time()

    pool = ThreadPool(processes=8)
    results2 = map(add, xrange(400000000))
    pool.close()
    pool.join()
    print ('Thread Pool:', time.time() - start2)```



多次 试验基本都这个结果::

    root@LFG1000186280:/tmp# python py-mulit-thread.py
    ('Normal:', 48.061574935913086)
    ('Thread Pool:', 52.3256778717041)


网上的帖子对比的是打开链接的速度，不属于CPU密集型操作， 其实无法说明GIL的影响，GIL本来就是在CPU密集型场景下有问题。          multiprocessing.dummy在多进程中开多线程，加上GIL的影响，线程切换开销，应该比多进程差才对。

## Reference
1. [segmentfualt](https://segmentfault.com/a/1190000000414339)

2. [multiprocessing.dummy 效率问题](http://stackoverflow.com/questions/26432411/multiprocessing-dummy-in-python)
</code></pre>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/wang-jian/python-multiprocessing">Python-multiprocessing</a> is maintained by <a href="https://github.com/wang-jian">wang-jian</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
